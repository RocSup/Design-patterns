**二、typescript入门**

**2.1、静态类型、故障检查**

JavaScript没有代码编译时报错

coding时提示

函数错误调用

变量错误赋值

**2.2、编译**

编译选项：

tsc	--init生成配置文件

tsc --noEmitOnError	//编译失败时，不生成新的js文件

tsconfig.json中配置“strict”

--noImplicitAny	//变量不明确时默认推断为any类型，并进行报错

--strictNullchecks	//对值为null和undefined的变量进行报错

编译特点：

类型擦除（生成的js文件中去除变量类型、字符串中${}强转）

降级编译（TS支持选择目标JS文件的版本）	tsc --target es2015 *.ts

**三、常用类型**

**3.1、基元类型**

string

number：不区分int或者float，数字统一为number

boolean

**3.2、数组**

let arr: number[] = [1, 2, 3];

let arr2: Array = [1, 2, 3];

**3.3、any**

防止某个特定值产生类型检查错误

值的类型为any，可以访问它的任何属性，也可分配给任何类型的值

使用noImplicitAny编译选项，会报错隐式any

**3.4、对象类型**

function printCoord(pt: {x: number; y: number}){

console.log("x:" + x + "y:" + y);

}

1、使用，或者；分隔对象的属性

2、属性可以不指定类型，默认any

3、属性名称后加？则该属性变为可选属性，可传参也可不传

function myPrint(obj: {first: string; lase?: string}){

//....

}

myPrint({ first: "hello"});

myPrint({ first: "hello", last: "world"})

注：JS访问不存在的属性，将获得值undefined而不会直接报错。因此，调用可选属性时，需要先进行undefined检查

if(obj.last != undefined){

//...法一，判断是否使用

}

//法二，调用时进行安全替代

console.log(obj.last?.toUpperCase());

**3.5、联合类型**

1、定义联合类型

function myPrint(id: number | string){

}

2、联合类型使用

联合类型使用时不能只调用匹配某个类型成员的方法，需要先进行判断

if(typeof id == "string")

if(Array.isArray(id))

typeof判断变量类型

instanceof判断是否属于类的实例

**3.6、类型别名**

类型别名可以为任何类型命名，可以是对象类型、联合类型

type Point = {

x: number;

y:number;

};

function printCoord(pt: {x: number; y: number}){

console.log("x:" + x + "y:" + y);

}

printCoord({ x: 100, y: 100});

**3.7、接口**

接口声明是另一种命名对象类型的方式

interface Point {

x: number;

y: number;

};

function printCoord(pt: {x: number; y: number}){

console.log("x:" + x + "y:" + y);

}

printCoord({ x: 100, y: 100});

类型别名和接口的区别：

扩展新类型的方式不同

A、扩展

扩展接口

interface A{

name: string

}

interface B exteds A{

honey: boolean

}

扩展新类型

type A = {

name: string

}

type B = A & {

honey: boolean

}

B、添加新字段

interface A {

name: string

}

interface A{

honey: boolean

}

类型创建后不可更改，不能进行声明合并

**3.8、类型断言**

const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;

const myCanvas = document.getElementById("main_canvas");

TS只允许类型断言为更具体的类型版本

也可进行强转，先转为unknown/any，再转为目标类型

const x = ("hello" as unknown) as number

**3.9、文字类型**

1、用法

除number、string类型外，可以在类型位置引用特定字符串和数字，规定值的范围

function myPrint(way : "left" | "right" | "center"){

}

myPrint("left");	//true

myPrint("up");	//false

2、问题

文字推理：

使用对象初始化变量时，TS假定该对象的属性值会变化

function handle(url: string, method: 'GET' | 'POST' | 'GUESS'){

}

const req = { url : "hello", method: 'GET' };

handle(req.url, req.method);	//报错

req.method推断为string

解决：

const req = { url : "hello", method: 'GET' as 'GET' };	//法1

handle(req.url, req.method as 'GET');	//法2

const req = { url : "hello", method: 'GET'} as const;	//法3

**3.10、null和undefined**

--strictNullchecks打开

需要对null或undefined值的属性或方法进行测试，而不能直接使用

法1

直接判断null或undefined时的情况

if (x == null){

}

法2

!判断不为空

function A(x?: number|null){

console.log(x!.toFixed());

}

**3.11、枚举**

枚举不是JavaScript类型级别的添加，而是直接添加到语言和运行时，慎用

![image-20230715082651153](D:\BreakingCoder\TypeScript\asset\image-20230715082651153.png)

**3.12、原语**

1、bigint，JS自ES2020用于大整数的原语

const num: bigint = BigInt(100);

const num: bigint = 100n;

2、symbol，通过函数创建全局唯一引用

```
const firstName = Symbol("name");
const secondNamme = Symbol("name");

if(firstName === secondName){
	//不会执行
}
```

因为firstName和secondName通过symbol创建，默认判断条件永远不会成立

**3.13、never**

never可以分配给任意类型，但是除never外没有类型可分配给never

**四、函数**

**4.1、函数类型表达式**

fn: (a: string) => void

type Function = (a: string) =>void;

函数类型表达式不允许声明属性

![image-20230715082346566](D:\BreakingCoder\TypeScript\asset\image-20230715082346566.png)

(someArg: number): boolean表示函数类型表达式
